{"version":3,"file":"static/js/277.b7f7f5ca.chunk.js","mappings":"sKAYA,MAAMA,EAAuBC,OAAO,6BAC9BC,EAAqBD,OAAO,2BAC5BE,EAAoBF,OAAO,0BAC3BG,EAAkBH,OAAO,wBAEzBI,GAAUC,EAAAA,EAAAA,eAAmB,CAAC,GAErB,SAASC,EAAKC,GAC3B,MAAM,OAAEC,EAAQC,UAAWC,EAAQ,CAAC,KAAMC,GAASJ,EAE7CK,GAAMC,EAAAA,EAAAA,SAAOC,EAAAA,EAAAA,UAAQ,YAASJ,MAAO,CAAC,EAAGK,QC+BzC,CAINC,IANDC,EAAMA,GAAO,IAAIC,IAchBC,GAAA,SAA6BC,EAAWC,GACvC,IAAMC,EAAmDL,EAAKM,IAAIH,GAC9DE,EACHA,EAASE,KAAKH,GAEdJ,EAAKQ,IAAIL,EAAM,CAACC,GAAA,EAWlBK,IAAA,SAA8BN,EAAWC,GACxC,IAAMC,EAAmDL,EAAKM,IAAIH,GAC9DE,IACCD,EACHC,EAASK,OAAOL,EAASM,QAAQP,KAAa,EAAG,GAEjDJ,EAAKQ,IAAIL,EAAM,MAelBS,KAAA,SAA+BT,EAAWC,GACzC,IAAIC,EAAWL,EAAKM,IAAIH,GACpBE,GACFA,EACCQ,QACAC,KAAI,SAACd,GACLA,EAAQI,EAAA,KAIXC,EAAWL,EAAKM,IAAI,OAElBD,EACCQ,QACAC,KAAI,SAACd,GACLA,EAAQG,EAAMC,EAAA,O,IAvEnBJ,CDxBkE,GAAE,MACnEH,EAAAA,EAAAA,UAAQ,IAAOF,EAAIoB,QAAQtB,MAAQA,GAAe,CAACA,KAEnDuB,EAAAA,EAAAA,YAAU,KACR,MAAM,QAAElB,GAAYH,EAAIoB,QAExB,MAAO,IAAMjB,EAAQC,IAAIkB,OAAO,GAC/B,IAEH,MAAM,QAAEnB,GAAYH,EAAIoB,QAExB,OACEG,EAAAA,EAAAA,KAAC/B,EAAQgC,SAAQ,CAACC,MAAOzB,EAAI0B,UAC3BH,EAAAA,EAAAA,KAAA,WACMxB,EACJ4B,SAAWlB,IACTA,EAAEmB,iBACFnB,EAAEoB,kBAEF,MACET,SAAWtB,MAAOgC,IAChB9B,EAEJJ,EAAOkC,GACJC,MAAMC,IACL7B,EAAQc,KAAK9B,EAAsB6C,EAAI,IAExCC,OAAOC,IACN/B,EAAQc,KAAK5B,EAAoB6C,EAAM,GACvC,KAKd,CEtDA,MAEA,EAFc,CAAEC,KCAD,SAAmBxC,GAChC,MAAM,KAAEyC,KAASrC,GAASJ,GAEnBG,EAAOuC,GHqDT,SAAqBC,EAAaC,GACvC,MAAMvC,GAAMwC,EAAAA,EAAAA,YAAWhD,IAEhBM,EAAOuC,IAAYI,EAAAA,EAAAA,WACxB,SAAAC,EAAA,OAAmC,QAAnCA,EAAMC,IAAAA,IAAM3C,EAAIoB,QAAQtB,MAAOwC,UAAI,IAAAI,EAAAA,EAAIH,CAAS,KAGlDlB,EAAAA,EAAAA,YAAU,IACDrB,EAAIoB,QAAQjB,QAAQI,GAAGhB,GAAiB,KAAO,IAADqD,EACnDP,EAAsC,QAA9BO,EAACD,IAAAA,IAAM3C,EAAIoB,QAAQtB,MAAOwC,UAAI,IAAAM,EAAAA,EAAIL,EAAU,KAErD,CAACA,EAAWD,EAAKtC,KAEpBqB,EAAAA,EAAAA,YAAU,IACDrB,EAAIoB,QAAQjB,QAAQI,GAAGjB,GAAoBuD,IAC3CF,IAAAA,IAAME,EAAKP,IAEhBD,EAASM,IAAAA,IAAME,EAAKP,GAAK,KAE1B,CAACC,EAAWD,EAAKtC,IAEpB,MAAM8C,GAAYC,EAAAA,EAAAA,cACfjD,IACC6C,IAAAA,IAAM3C,EAAIoB,QAAQtB,MAAOwC,EAAKxC,GAC9BuC,EAASvC,EAAM,GAEjB,CAACwC,EAAKtC,IAGR,MAAO,CAACF,EAAOgD,EACjB,CGnF4BE,CAASZ,EAAM,IAEzC,OACEb,EAAAA,EAAAA,KAAA,YACMxB,EACJkD,KAAK,OACLxB,MAAO3B,EACPoD,SAAUC,IAAA,IAAC,cAAEC,GAAeD,EAAA,OAAKd,EAASe,EAAc3B,MAAM,GAGpE,G,aCEA,SAAS4B,IACP,MAAMC,EJwED,WACL,MAAMtD,GAAMwC,EAAAA,EAAAA,YAAWhD,IAEhBM,EAAOuC,IAAYI,EAAAA,EAAAA,YAQ1B,OANApB,EAAAA,EAAAA,YAAU,IACDrB,EAAIoB,QAAQjB,QAAQI,GAAGpB,GAAuBsB,IACnD4B,EAAS5B,EAAE,KAEZ,CAACT,IAEGF,CACT,CIpFkByD,IACTzD,EAAOuC,IAAYI,EAAAA,EAAAA,UAAS,IAC7BtC,EJkGD,WACL,MAAMH,GAAMwC,EAAAA,EAAAA,YAAWhD,GAEvB,OAAOU,EAAAA,EAAAA,UAAQ,KACb,MAAM,QAAEC,GAAYH,EAAIoB,QAElBb,EAAKA,CAACiD,EAAeC,IAAmBtD,EAAQI,GAAGiD,EAAOC,GAE1DC,EAASb,IACbF,IAAAA,MAAQ3C,EAAIoB,QAAQtB,MAAO+C,GAC3B1C,EAAQc,KAAK3B,EAAmBuD,EAAI,EAGtC,OAAO,IAAIc,MAAMxD,EAAS,CACxBQ,GAAAA,CAAIR,EAAkBqD,GACpB,OAAQA,GACN,IAAK,KACH,OAAOjD,EACT,IAAK,QACH,OAAOmD,EACT,QACE,OAAQ5B,GAAqB3B,EAAQc,KAAKuC,EAAO1B,GAEvD,GACA,GACD,CAAC9B,GACN,CI5HkB4D,GAIhB,OAFAvC,EAAAA,EAAAA,YAAU,IAAMlB,EAAQI,GAAG,SAAU8B,IAAW,CAAClC,IAE5CmD,GASE/B,EAAAA,EAAAA,KAAA,QAAAG,SAAO4B,KAPVO,EAAAA,EAAAA,MAAA,OAAAnC,SAAA,EACEH,EAAAA,EAAAA,KAAA,QAAMuC,QAASA,IAAM3D,EAAQ4D,OAAO,OAAOrC,SAAC,aAC5CH,EAAAA,EAAAA,KAAA,QAAAG,SAAO5B,MAMf,CAEA,QA9BA,WACE,OACE+D,EAAAA,EAAAA,MAACnE,EAAI,CAACE,OAAQoE,EAAAA,SAAStC,SAAA,EACrBH,EAAAA,EAAAA,KAAC0C,EAAM9B,KAAI,CAACC,KAAK,cACjBb,EAAAA,EAAAA,KAAC0C,EAAM9B,KAAI,CAACC,KAAK,kBACjBb,EAAAA,EAAAA,KAAC8B,EAAO,KACR9B,EAAAA,EAAAA,KAAA,SAAO0B,KAAK,SAASxB,MAAM,aAGjC,C","sources":["Form/index.tsx","../../../node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/src/index.ts","Form/Input/index.ts","Form/Input/Text.tsx","App.tsx"],"sourcesContent":["import _ from \"lodash\";\r\nimport mitt from \"mitt\";\r\nimport {\r\n  createContext,\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from \"react\";\r\n\r\nconst EVENT_ACTION_SUCCESS = Symbol(\"FORM_EVENT_ACTION_SUCCESS\");\r\nconst EVENT_ACTION_ERROR = Symbol(\"FORM_EVENT_ACTION_ERROR\");\r\nconst EVENT_MERGE_STATE = Symbol(\"FORM_EVENT_MERGE_STATE\");\r\nconst EVENT_SET_STATE = Symbol(\"FORM_EVENT_SET_STATE\");\r\n\r\nconst Context = createContext<any>({});\r\n\r\nexport default function Form(props: Props) {\r\n  const { action, initState: state = {}, ...core } = props;\r\n\r\n  const ref = useRef(useMemo(() => ({ state: {}, emitter: mitt() }), []));\r\n  useMemo(() => (ref.current.state = state as any), [state]);\r\n\r\n  useEffect(() => {\r\n    const { emitter } = ref.current;\r\n\r\n    return () => emitter.all.clear();\r\n  }, []);\r\n\r\n  const { emitter } = ref.current;\r\n\r\n  return (\r\n    <Context.Provider value={ref}>\r\n      <form\r\n        {...core}\r\n        onSubmit={(e) => {\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n\r\n          const {\r\n            current: { state: payload },\r\n          } = ref;\r\n\r\n          action(payload)\r\n            .then((res: unknown) => {\r\n              emitter.emit(EVENT_ACTION_SUCCESS, res);\r\n            })\r\n            .catch((error: unknown) => {\r\n              emitter.emit(EVENT_ACTION_ERROR, error);\r\n            });\r\n        }}\r\n      />\r\n    </Context.Provider>\r\n  );\r\n}\r\n\r\nexport function useInput<T>(key: string, initValue: T) {\r\n  const ref = useContext(Context);\r\n\r\n  const [state, setState] = useState<T>(\r\n    () => _.get(ref.current.state, key) ?? initValue\r\n  );\r\n\r\n  useEffect(() => {\r\n    return ref.current.emitter.on(EVENT_SET_STATE, () => {\r\n      setState(_.get(ref.current.state, key) ?? initValue);\r\n    });\r\n  }, [initValue, key, ref]);\r\n\r\n  useEffect(() => {\r\n    return ref.current.emitter.on(EVENT_MERGE_STATE, (src: any) => {\r\n      if (!_.has(src, key)) return;\r\n\r\n      setState(_.get(src, key));\r\n    });\r\n  }, [initValue, key, ref]);\r\n\r\n  const _setState = useCallback(\r\n    (state: T) => {\r\n      _.set(ref.current.state, key, state);\r\n      setState(state);\r\n    },\r\n    [key, ref]\r\n  );\r\n\r\n  return [state, _setState] as const;\r\n}\r\n\r\nexport function useOnActionSuccess<T>() {\r\n  const ref = useContext(Context);\r\n\r\n  const [state, setState] = useState<unknown>();\r\n\r\n  useEffect(() => {\r\n    return ref.current.emitter.on(EVENT_ACTION_SUCCESS, (e: unknown) => {\r\n      setState(e);\r\n    });\r\n  }, [ref]);\r\n\r\n  return state as undefined | T;\r\n}\r\n\r\nexport function useOnActionError<T = unknown>() {\r\n  const ref = useContext(Context);\r\n\r\n  const [state, setState] = useState<unknown>();\r\n\r\n  useEffect(() => {\r\n    return ref.current.emitter.on(EVENT_ACTION_ERROR, (e: unknown) => {\r\n      setState(e);\r\n    });\r\n  }, [ref]);\r\n\r\n  return state as undefined | T;\r\n}\r\n\r\nexport function useEmitter(): EmitterProxy {\r\n  const ref = useContext(Context);\r\n\r\n  return useMemo(() => {\r\n    const { emitter } = ref.current;\r\n\r\n    const on = (event: string, cb: () => void) => emitter.on(event, cb);\r\n\r\n    const merge = (src: {}) => {\r\n      _.merge(ref.current.state, src);\r\n      emitter.emit(EVENT_MERGE_STATE, src);\r\n    };\r\n\r\n    return new Proxy(emitter, {\r\n      get(emitter: Emitter, event) {\r\n        switch (event) {\r\n          case \"on\":\r\n            return on;\r\n          case \"merge\":\r\n            return merge;\r\n          default:\r\n            return (payload: unknown) => emitter.emit(event, payload);\r\n        }\r\n      },\r\n    });\r\n  }, [ref]);\r\n}\r\n\r\n/**\r\n * Types\r\n */\r\n\r\ninterface Props extends Core {\r\n  initState?: unknown;\r\n  action: any;\r\n}\r\n\r\ntype Core = Omit<JSX.IntrinsicElements[\"form\"], \"action\">;\r\n\r\ntype EmitterProxy = {\r\n  [K: string]: (...args: unknown[]) => void;\r\n  //on: (event: string, cb: <T>(payload: T) => void) => () => void;\r\n};\r\n\r\ntype Emitter = ReturnType<typeof mitt>;\r\n","export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n","import Text from \"./Text\";\r\n\r\nconst Input = { Text };\r\n\r\nexport default Input;\r\n","import { useInput } from \"..\";\r\n\r\nexport default function InputText(props: Props) {\r\n  const { name, ...core } = props;\r\n\r\n  const [state, setState] = useInput(name, \"\");\r\n\r\n  return (\r\n    <input\r\n      {...core}\r\n      type=\"text\"\r\n      value={state}\r\n      onChange={({ currentTarget }) => setState(currentTarget.value)}\r\n    />\r\n  );\r\n}\r\n\r\ninterface Props extends Core {\r\n  name: string;\r\n}\r\n\r\ntype Core = Omit<\r\n  JSX.IntrinsicElements[\"input\"],\r\n  \"value\" | \"name\" | \"onChange\" | \"type\"\r\n>;\r\n","import React, { useEffect, useState } from \"react\";\r\nimport \"./App.css\";\r\nimport Form, { useOnActionSuccess, useEmitter } from \"./Form\";\r\nimport Input from \"./Form/Input\";\r\nimport { sayHello } from \"backend/service\";\r\n\r\nfunction App() {\r\n  return (\r\n    <Form action={sayHello}>\r\n      <Input.Text name=\"fullName\" />\r\n      <Input.Text name=\"foo.fullName\" />\r\n      <Success />\r\n      <input type=\"submit\" value=\"Enviar\" />\r\n    </Form>\r\n  );\r\n}\r\n\r\nfunction Success() {\r\n  const message = useOnActionSuccess<string>();\r\n  const [state, setState] = useState(\"\");\r\n  const emitter = useEmitter();\r\n\r\n  useEffect(() => emitter.on(\"sayFoo\", setState), [emitter]);\r\n\r\n  if (!message) {\r\n    return (\r\n      <div>\r\n        <span onClick={() => emitter.sayFoo(\"foo\")}>Emitter</span>\r\n        <span>{state}</span>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return <span>{message}</span>;\r\n}\r\n\r\nexport default App;\r\n"],"names":["EVENT_ACTION_SUCCESS","Symbol","EVENT_ACTION_ERROR","EVENT_MERGE_STATE","EVENT_SET_STATE","Context","createContext","Form","props","action","initState","state","core","ref","useRef","useMemo","emitter","all","n","Map","on","t","e","i","get","push","set","off","splice","indexOf","emit","slice","map","current","useEffect","clear","_jsx","Provider","value","children","onSubmit","preventDefault","stopPropagation","payload","then","res","catch","error","Text","name","setState","key","initValue","useContext","useState","_$get","_","_$get2","src","_setState","useCallback","useInput","type","onChange","_ref","currentTarget","Success","message","useOnActionSuccess","event","cb","merge","Proxy","useEmitter","_jsxs","onClick","sayFoo","sayHello","Input"],"sourceRoot":""}